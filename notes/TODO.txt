未完成
    测试parsed model的正确性.在NNRegressor中测试以及checker中测试.
        要验证的方面:比较parsed model和ModelFactory生成的model之间的异同.
        ModelFactory返回的model: labels + modules + stop_condition
        ModelFactory_model:
            repeated Module modules;
            repeated Label label;
            optional Label stop_condition;
        Module:
            string name;
            repeated Constant constants;
            repeated Variable variables;
            repeated Command commands;
        Label:
            string name;
            function bool_expr;

        Thus, comparison step in step:
            1. all constants name value 
            2. variables valrange init_value 
            3. commands guard prob action 

        comparison result:
            1. _F, _U in model solution: call model._fillinstate()
            2. failurecondition UI
            3. stopcondition UI


    LTL公式的输入 UI
    prepareCommands调用有必要，可减少产生随机路径时间。
    testChecker.py要获取哪些数据？要验证哪些数据？
        1. 对模型进行大数据量的抽取随机路径，应该确保符合ltl性质的路径所占总路径数的比重大体相同。
        2. 确保parsed模型和built模型在每一天的损坏概率均相同。CHECKED.(确保了SB模块和S3R模块在相同的天数下，parsed和built模型的相应模块的损坏概率相同)
    还是从另一个角度，不去验证两者的不同，而是直接去跑checker和regressor？
    ??? 为什么parsed和built的模型在生成随机路径的时间不同？
        通过使用cprofile模块,对parsed和built模型生成随机路径的时间进行了测试,发现前者是后者的两倍,总结,发现是如下代码所致:
        PRISMParser.py中待优化的代码:
        '''factor : NAME'''
        def f():
            obj = self.vcf_map[name]
            if callable(obj):
                return obj()
            return obj.getValue()

        '''expr : expr ADD/MINUS expr'''
        def f():
            '''binary expression function'''
            v1 = slice_copy[1].value()
            v2 = slice_copy[3].value()
            if op == '-':
                return v1 - v2
            else:
                return v1 + v2

        '''NAME LP expr RP'''
        def f():
            return func(slice[3].value())

        '''term MUL/DIV factor'''
        def f():
            v1 = slice_copy[1].value()
            v2 = slice_copy[3].value()
            if op == "*":
                return v1 * v2
            else:
                return v1 / v2

    一种优化策略:
        1. 提前计算每个day对应的failure probability.

已完成
如何确保expression的parsing是正确的？ 单元测试成功 testParseExpr.py
增加label,测试label testLabel.py单元测试成功
修改command语法规则,增加name解析
比较了parsed model和built model之间的异同,即check了两个模型在相同的天数下各个模块的损坏概率,结果是相同.


不足
目前command的update部分不允许出现boolean_expression
因为在parse module的时候,默认将所有的boolean_expression解析为当前command的guard
