Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    LOG
    MIN
    NUMBERSIGN
    GLOBAL
    MODELTYPE
    LABEL
    QUOTE
    EXP
    TRUE
    POW
    STDCDF
    FALSE
    MAX
    NOT
    TYPE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> model_type_statement
Rule 2     statement -> const_value_statement
Rule 3     statement -> module_def_begin_statement
Rule 4     statement -> module_def_end_statement
Rule 5     statement -> module_var_def_statement
Rule 6     statement -> module_command_statement
Rule 7     statement -> formula_statement
Rule 8     model_type_statement -> DTMC
Rule 9     model_type_statement -> CTMC
Rule 10    module_def_begin_statement -> MODULE NAME
Rule 11    module_def_end_statement -> ENDMODULE
Rule 12    const_value_statement -> CONST INT NAME ASSIGN NUM SEMICOLON
Rule 13    const_value_statement -> CONST DOUBLE NAME ASSIGN NUM SEMICOLON
Rule 14    const_value_statement -> CONST BOOL NAME ASSIGN NUM SEMICOLON
Rule 15    const_value_statement -> CONST INT NAME SEMICOLON
Rule 16    const_value_statement -> CONST DOUBLE NAME SEMICOLON
Rule 17    const_value_statement -> CONST BOOL NAME SEMICOLON
Rule 18    const_value_statement -> CONST INT NAME ASSIGN expr SEMICOLON
Rule 19    const_value_statement -> CONST DOUBLE NAME ASSIGN expr SEMICOLON
Rule 20    const_value_statement -> CONST BOOL NAME ASSIGN expr SEMICOLON
Rule 21    module_var_def_statement -> NAME COLON LB expr COMMA expr RB INIT NUM SEMICOLON
Rule 22    module_command_statement -> LB RB boolean_expression THEN updates SEMICOLON
Rule 23    updates -> updates ADD prob_update
Rule 24    updates -> prob_update
Rule 25    prob_update -> expr COLON actions
Rule 26    actions -> actions AND assignment
Rule 27    actions -> assignment
Rule 28    assignment -> NAME ASSIGN expr
Rule 29    assignment -> LP NAME ASSIGN expr RP
Rule 30    expr -> expr ADD term
Rule 31    expr -> expr MINUS term
Rule 32    expr -> term
Rule 33    term -> term MUL factor
Rule 34    term -> term DIV factor
Rule 35    term -> factor
Rule 36    factor -> NUM
Rule 37    factor -> NAME
Rule 38    boolean_expression -> boolean_expression AND boolean_expression_unit
Rule 39    boolean_expression -> boolean_expression OR boolean_expression_unit
Rule 40    boolean_expression -> boolean_expression_unit
Rule 41    boolean_expression_unit -> NAME GT NUM
Rule 42    boolean_expression_unit -> NAME LT NUM
Rule 43    boolean_expression_unit -> NAME GE NUM
Rule 44    boolean_expression_unit -> NAME LE NUM
Rule 45    boolean_expression_unit -> NAME EQ NUM
Rule 46    boolean_expression_unit -> NAME NEQ NUM
Rule 47    boolean_expression_unit -> NAME GT expr
Rule 48    boolean_expression_unit -> NAME LT expr
Rule 49    boolean_expression_unit -> NAME GE expr
Rule 50    boolean_expression_unit -> NAME LE expr
Rule 51    boolean_expression_unit -> NAME EQ expr
Rule 52    boolean_expression_unit -> NAME NEQ expr
Rule 53    formula_statement -> FORMULA NAME ASSIGN expr SEMICOLON

Terminals, with rules where they appear

ADD                  : 23 30
AND                  : 26 38
ASSIGN               : 12 13 14 18 19 20 28 29 53
BOOL                 : 14 17 20
COLON                : 21 25
COMMA                : 21
CONST                : 12 13 14 15 16 17 18 19 20
CTMC                 : 9
DIV                  : 34
DOUBLE               : 13 16 19
DTMC                 : 8
ENDMODULE            : 11
EQ                   : 45 51
EXP                  : 
FALSE                : 
FORMULA              : 53
GE                   : 43 49
GLOBAL               : 
GT                   : 41 47
INIT                 : 21
INT                  : 12 15 18
LABEL                : 
LB                   : 21 22
LE                   : 44 50
LOG                  : 
LP                   : 29
LT                   : 42 48
MAX                  : 
MIN                  : 
MINUS                : 31
MODELTYPE            : 
MODULE               : 10
MUL                  : 33
NAME                 : 10 12 13 14 15 16 17 18 19 20 21 28 29 37 41 42 43 44 45 46 47 48 49 50 51 52 53
NEQ                  : 46 52
NOT                  : 
NUM                  : 12 13 14 21 36 41 42 43 44 45 46
NUMBERSIGN           : 
OR                   : 39
POW                  : 
QUOTE                : 
RB                   : 21 22
RP                   : 29
SEMICOLON            : 12 13 14 15 16 17 18 19 20 21 22 53
STDCDF               : 
THEN                 : 22
TRUE                 : 
TYPE                 : 
error                : 

Nonterminals, with rules where they appear

actions              : 25 26
assignment           : 26 27
boolean_expression   : 22 38 39
boolean_expression_unit : 38 39 40
const_value_statement : 2
expr                 : 18 19 20 21 21 25 28 29 30 31 47 48 49 50 51 52 53
factor               : 33 34 35
formula_statement    : 7
model_type_statement : 1
module_command_statement : 6
module_def_begin_statement : 3
module_def_end_statement : 4
module_var_def_statement : 5
prob_update          : 23 24
statement            : 0
term                 : 30 31 32 33 34
updates              : 22 23

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . model_type_statement
    (2) statement -> . const_value_statement
    (3) statement -> . module_def_begin_statement
    (4) statement -> . module_def_end_statement
    (5) statement -> . module_var_def_statement
    (6) statement -> . module_command_statement
    (7) statement -> . formula_statement
    (8) model_type_statement -> . DTMC
    (9) model_type_statement -> . CTMC
    (12) const_value_statement -> . CONST INT NAME ASSIGN NUM SEMICOLON
    (13) const_value_statement -> . CONST DOUBLE NAME ASSIGN NUM SEMICOLON
    (14) const_value_statement -> . CONST BOOL NAME ASSIGN NUM SEMICOLON
    (15) const_value_statement -> . CONST INT NAME SEMICOLON
    (16) const_value_statement -> . CONST DOUBLE NAME SEMICOLON
    (17) const_value_statement -> . CONST BOOL NAME SEMICOLON
    (18) const_value_statement -> . CONST INT NAME ASSIGN expr SEMICOLON
    (19) const_value_statement -> . CONST DOUBLE NAME ASSIGN expr SEMICOLON
    (20) const_value_statement -> . CONST BOOL NAME ASSIGN expr SEMICOLON
    (10) module_def_begin_statement -> . MODULE NAME
    (11) module_def_end_statement -> . ENDMODULE
    (21) module_var_def_statement -> . NAME COLON LB expr COMMA expr RB INIT NUM SEMICOLON
    (22) module_command_statement -> . LB RB boolean_expression THEN updates SEMICOLON
    (53) formula_statement -> . FORMULA NAME ASSIGN expr SEMICOLON

    DTMC            shift and go to state 2
    CTMC            shift and go to state 3
    CONST           shift and go to state 1
    MODULE          shift and go to state 12
    ENDMODULE       shift and go to state 10
    NAME            shift and go to state 15
    LB              shift and go to state 7
    FORMULA         shift and go to state 5

    const_value_statement          shift and go to state 13
    module_def_end_statement       shift and go to state 6
    model_type_statement           shift and go to state 14
    module_command_statement       shift and go to state 4
    module_var_def_statement       shift and go to state 11
    statement                      shift and go to state 8
    formula_statement              shift and go to state 16
    module_def_begin_statement     shift and go to state 9

state 1

    (12) const_value_statement -> CONST . INT NAME ASSIGN NUM SEMICOLON
    (13) const_value_statement -> CONST . DOUBLE NAME ASSIGN NUM SEMICOLON
    (14) const_value_statement -> CONST . BOOL NAME ASSIGN NUM SEMICOLON
    (15) const_value_statement -> CONST . INT NAME SEMICOLON
    (16) const_value_statement -> CONST . DOUBLE NAME SEMICOLON
    (17) const_value_statement -> CONST . BOOL NAME SEMICOLON
    (18) const_value_statement -> CONST . INT NAME ASSIGN expr SEMICOLON
    (19) const_value_statement -> CONST . DOUBLE NAME ASSIGN expr SEMICOLON
    (20) const_value_statement -> CONST . BOOL NAME ASSIGN expr SEMICOLON

    INT             shift and go to state 17
    DOUBLE          shift and go to state 18
    BOOL            shift and go to state 19


state 2

    (8) model_type_statement -> DTMC .

    $end            reduce using rule 8 (model_type_statement -> DTMC .)


state 3

    (9) model_type_statement -> CTMC .

    $end            reduce using rule 9 (model_type_statement -> CTMC .)


state 4

    (6) statement -> module_command_statement .

    $end            reduce using rule 6 (statement -> module_command_statement .)


state 5

    (53) formula_statement -> FORMULA . NAME ASSIGN expr SEMICOLON

    NAME            shift and go to state 20


state 6

    (4) statement -> module_def_end_statement .

    $end            reduce using rule 4 (statement -> module_def_end_statement .)


state 7

    (22) module_command_statement -> LB . RB boolean_expression THEN updates SEMICOLON

    RB              shift and go to state 21


state 8

    (0) S' -> statement .



state 9

    (3) statement -> module_def_begin_statement .

    $end            reduce using rule 3 (statement -> module_def_begin_statement .)


state 10

    (11) module_def_end_statement -> ENDMODULE .

    $end            reduce using rule 11 (module_def_end_statement -> ENDMODULE .)


state 11

    (5) statement -> module_var_def_statement .

    $end            reduce using rule 5 (statement -> module_var_def_statement .)


state 12

    (10) module_def_begin_statement -> MODULE . NAME

    NAME            shift and go to state 22


state 13

    (2) statement -> const_value_statement .

    $end            reduce using rule 2 (statement -> const_value_statement .)


state 14

    (1) statement -> model_type_statement .

    $end            reduce using rule 1 (statement -> model_type_statement .)


state 15

    (21) module_var_def_statement -> NAME . COLON LB expr COMMA expr RB INIT NUM SEMICOLON

    COLON           shift and go to state 23


state 16

    (7) statement -> formula_statement .

    $end            reduce using rule 7 (statement -> formula_statement .)


state 17

    (12) const_value_statement -> CONST INT . NAME ASSIGN NUM SEMICOLON
    (15) const_value_statement -> CONST INT . NAME SEMICOLON
    (18) const_value_statement -> CONST INT . NAME ASSIGN expr SEMICOLON

    NAME            shift and go to state 24


state 18

    (13) const_value_statement -> CONST DOUBLE . NAME ASSIGN NUM SEMICOLON
    (16) const_value_statement -> CONST DOUBLE . NAME SEMICOLON
    (19) const_value_statement -> CONST DOUBLE . NAME ASSIGN expr SEMICOLON

    NAME            shift and go to state 25


state 19

    (14) const_value_statement -> CONST BOOL . NAME ASSIGN NUM SEMICOLON
    (17) const_value_statement -> CONST BOOL . NAME SEMICOLON
    (20) const_value_statement -> CONST BOOL . NAME ASSIGN expr SEMICOLON

    NAME            shift and go to state 26


state 20

    (53) formula_statement -> FORMULA NAME . ASSIGN expr SEMICOLON

    ASSIGN          shift and go to state 27


state 21

    (22) module_command_statement -> LB RB . boolean_expression THEN updates SEMICOLON
    (38) boolean_expression -> . boolean_expression AND boolean_expression_unit
    (39) boolean_expression -> . boolean_expression OR boolean_expression_unit
    (40) boolean_expression -> . boolean_expression_unit
    (41) boolean_expression_unit -> . NAME GT NUM
    (42) boolean_expression_unit -> . NAME LT NUM
    (43) boolean_expression_unit -> . NAME GE NUM
    (44) boolean_expression_unit -> . NAME LE NUM
    (45) boolean_expression_unit -> . NAME EQ NUM
    (46) boolean_expression_unit -> . NAME NEQ NUM
    (47) boolean_expression_unit -> . NAME GT expr
    (48) boolean_expression_unit -> . NAME LT expr
    (49) boolean_expression_unit -> . NAME GE expr
    (50) boolean_expression_unit -> . NAME LE expr
    (51) boolean_expression_unit -> . NAME EQ expr
    (52) boolean_expression_unit -> . NAME NEQ expr

    NAME            shift and go to state 28

    boolean_expression_unit        shift and go to state 30
    boolean_expression             shift and go to state 29

state 22

    (10) module_def_begin_statement -> MODULE NAME .

    $end            reduce using rule 10 (module_def_begin_statement -> MODULE NAME .)


state 23

    (21) module_var_def_statement -> NAME COLON . LB expr COMMA expr RB INIT NUM SEMICOLON

    LB              shift and go to state 31


state 24

    (12) const_value_statement -> CONST INT NAME . ASSIGN NUM SEMICOLON
    (15) const_value_statement -> CONST INT NAME . SEMICOLON
    (18) const_value_statement -> CONST INT NAME . ASSIGN expr SEMICOLON

    ASSIGN          shift and go to state 33
    SEMICOLON       shift and go to state 32


state 25

    (13) const_value_statement -> CONST DOUBLE NAME . ASSIGN NUM SEMICOLON
    (16) const_value_statement -> CONST DOUBLE NAME . SEMICOLON
    (19) const_value_statement -> CONST DOUBLE NAME . ASSIGN expr SEMICOLON

    ASSIGN          shift and go to state 35
    SEMICOLON       shift and go to state 34


state 26

    (14) const_value_statement -> CONST BOOL NAME . ASSIGN NUM SEMICOLON
    (17) const_value_statement -> CONST BOOL NAME . SEMICOLON
    (20) const_value_statement -> CONST BOOL NAME . ASSIGN expr SEMICOLON

    ASSIGN          shift and go to state 37
    SEMICOLON       shift and go to state 36


state 27

    (53) formula_statement -> FORMULA NAME ASSIGN . expr SEMICOLON
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 42
    NAME            shift and go to state 39

    expr                           shift and go to state 40
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 28

    (41) boolean_expression_unit -> NAME . GT NUM
    (42) boolean_expression_unit -> NAME . LT NUM
    (43) boolean_expression_unit -> NAME . GE NUM
    (44) boolean_expression_unit -> NAME . LE NUM
    (45) boolean_expression_unit -> NAME . EQ NUM
    (46) boolean_expression_unit -> NAME . NEQ NUM
    (47) boolean_expression_unit -> NAME . GT expr
    (48) boolean_expression_unit -> NAME . LT expr
    (49) boolean_expression_unit -> NAME . GE expr
    (50) boolean_expression_unit -> NAME . LE expr
    (51) boolean_expression_unit -> NAME . EQ expr
    (52) boolean_expression_unit -> NAME . NEQ expr

    GT              shift and go to state 44
    LT              shift and go to state 46
    GE              shift and go to state 45
    LE              shift and go to state 43
    EQ              shift and go to state 47
    NEQ             shift and go to state 48


state 29

    (22) module_command_statement -> LB RB boolean_expression . THEN updates SEMICOLON
    (38) boolean_expression -> boolean_expression . AND boolean_expression_unit
    (39) boolean_expression -> boolean_expression . OR boolean_expression_unit

    THEN            shift and go to state 50
    AND             shift and go to state 49
    OR              shift and go to state 51


state 30

    (40) boolean_expression -> boolean_expression_unit .

    THEN            reduce using rule 40 (boolean_expression -> boolean_expression_unit .)
    AND             reduce using rule 40 (boolean_expression -> boolean_expression_unit .)
    OR              reduce using rule 40 (boolean_expression -> boolean_expression_unit .)


state 31

    (21) module_var_def_statement -> NAME COLON LB . expr COMMA expr RB INIT NUM SEMICOLON
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 42
    NAME            shift and go to state 39

    expr                           shift and go to state 52
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 32

    (15) const_value_statement -> CONST INT NAME SEMICOLON .

    $end            reduce using rule 15 (const_value_statement -> CONST INT NAME SEMICOLON .)


state 33

    (12) const_value_statement -> CONST INT NAME ASSIGN . NUM SEMICOLON
    (18) const_value_statement -> CONST INT NAME ASSIGN . expr SEMICOLON
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 54
    NAME            shift and go to state 39

    expr                           shift and go to state 53
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 34

    (16) const_value_statement -> CONST DOUBLE NAME SEMICOLON .

    $end            reduce using rule 16 (const_value_statement -> CONST DOUBLE NAME SEMICOLON .)


state 35

    (13) const_value_statement -> CONST DOUBLE NAME ASSIGN . NUM SEMICOLON
    (19) const_value_statement -> CONST DOUBLE NAME ASSIGN . expr SEMICOLON
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 55
    NAME            shift and go to state 39

    expr                           shift and go to state 56
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 36

    (17) const_value_statement -> CONST BOOL NAME SEMICOLON .

    $end            reduce using rule 17 (const_value_statement -> CONST BOOL NAME SEMICOLON .)


state 37

    (14) const_value_statement -> CONST BOOL NAME ASSIGN . NUM SEMICOLON
    (20) const_value_statement -> CONST BOOL NAME ASSIGN . expr SEMICOLON
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 58
    NAME            shift and go to state 39

    expr                           shift and go to state 57
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 38

    (32) expr -> term .
    (33) term -> term . MUL factor
    (34) term -> term . DIV factor

    SEMICOLON       reduce using rule 32 (expr -> term .)
    ADD             reduce using rule 32 (expr -> term .)
    MINUS           reduce using rule 32 (expr -> term .)
    THEN            reduce using rule 32 (expr -> term .)
    AND             reduce using rule 32 (expr -> term .)
    OR              reduce using rule 32 (expr -> term .)
    COLON           reduce using rule 32 (expr -> term .)
    COMMA           reduce using rule 32 (expr -> term .)
    RP              reduce using rule 32 (expr -> term .)
    RB              reduce using rule 32 (expr -> term .)
    MUL             shift and go to state 59
    DIV             shift and go to state 60


state 39

    (37) factor -> NAME .

    MUL             reduce using rule 37 (factor -> NAME .)
    DIV             reduce using rule 37 (factor -> NAME .)
    SEMICOLON       reduce using rule 37 (factor -> NAME .)
    ADD             reduce using rule 37 (factor -> NAME .)
    MINUS           reduce using rule 37 (factor -> NAME .)
    THEN            reduce using rule 37 (factor -> NAME .)
    AND             reduce using rule 37 (factor -> NAME .)
    OR              reduce using rule 37 (factor -> NAME .)
    COMMA           reduce using rule 37 (factor -> NAME .)
    COLON           reduce using rule 37 (factor -> NAME .)
    RB              reduce using rule 37 (factor -> NAME .)
    RP              reduce using rule 37 (factor -> NAME .)


state 40

    (53) formula_statement -> FORMULA NAME ASSIGN expr . SEMICOLON
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 61
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 41

    (35) term -> factor .

    MUL             reduce using rule 35 (term -> factor .)
    DIV             reduce using rule 35 (term -> factor .)
    ADD             reduce using rule 35 (term -> factor .)
    MINUS           reduce using rule 35 (term -> factor .)
    THEN            reduce using rule 35 (term -> factor .)
    AND             reduce using rule 35 (term -> factor .)
    OR              reduce using rule 35 (term -> factor .)
    RB              reduce using rule 35 (term -> factor .)
    COMMA           reduce using rule 35 (term -> factor .)
    SEMICOLON       reduce using rule 35 (term -> factor .)
    RP              reduce using rule 35 (term -> factor .)
    COLON           reduce using rule 35 (term -> factor .)


state 42

    (36) factor -> NUM .

    MUL             reduce using rule 36 (factor -> NUM .)
    DIV             reduce using rule 36 (factor -> NUM .)
    SEMICOLON       reduce using rule 36 (factor -> NUM .)
    ADD             reduce using rule 36 (factor -> NUM .)
    MINUS           reduce using rule 36 (factor -> NUM .)
    COMMA           reduce using rule 36 (factor -> NUM .)
    THEN            reduce using rule 36 (factor -> NUM .)
    AND             reduce using rule 36 (factor -> NUM .)
    OR              reduce using rule 36 (factor -> NUM .)
    COLON           reduce using rule 36 (factor -> NUM .)
    RB              reduce using rule 36 (factor -> NUM .)
    RP              reduce using rule 36 (factor -> NUM .)


state 43

    (44) boolean_expression_unit -> NAME LE . NUM
    (50) boolean_expression_unit -> NAME LE . expr
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 65
    NAME            shift and go to state 39

    expr                           shift and go to state 64
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 44

    (41) boolean_expression_unit -> NAME GT . NUM
    (47) boolean_expression_unit -> NAME GT . expr
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 67
    NAME            shift and go to state 39

    expr                           shift and go to state 66
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 45

    (43) boolean_expression_unit -> NAME GE . NUM
    (49) boolean_expression_unit -> NAME GE . expr
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 69
    NAME            shift and go to state 39

    expr                           shift and go to state 68
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 46

    (42) boolean_expression_unit -> NAME LT . NUM
    (48) boolean_expression_unit -> NAME LT . expr
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 71
    NAME            shift and go to state 39

    expr                           shift and go to state 70
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 47

    (45) boolean_expression_unit -> NAME EQ . NUM
    (51) boolean_expression_unit -> NAME EQ . expr
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 73
    NAME            shift and go to state 39

    expr                           shift and go to state 72
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 48

    (46) boolean_expression_unit -> NAME NEQ . NUM
    (52) boolean_expression_unit -> NAME NEQ . expr
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 75
    NAME            shift and go to state 39

    expr                           shift and go to state 74
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 49

    (38) boolean_expression -> boolean_expression AND . boolean_expression_unit
    (41) boolean_expression_unit -> . NAME GT NUM
    (42) boolean_expression_unit -> . NAME LT NUM
    (43) boolean_expression_unit -> . NAME GE NUM
    (44) boolean_expression_unit -> . NAME LE NUM
    (45) boolean_expression_unit -> . NAME EQ NUM
    (46) boolean_expression_unit -> . NAME NEQ NUM
    (47) boolean_expression_unit -> . NAME GT expr
    (48) boolean_expression_unit -> . NAME LT expr
    (49) boolean_expression_unit -> . NAME GE expr
    (50) boolean_expression_unit -> . NAME LE expr
    (51) boolean_expression_unit -> . NAME EQ expr
    (52) boolean_expression_unit -> . NAME NEQ expr

    NAME            shift and go to state 28

    boolean_expression_unit        shift and go to state 76

state 50

    (22) module_command_statement -> LB RB boolean_expression THEN . updates SEMICOLON
    (23) updates -> . updates ADD prob_update
    (24) updates -> . prob_update
    (25) prob_update -> . expr COLON actions
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 42
    NAME            shift and go to state 39

    term                           shift and go to state 38
    expr                           shift and go to state 77
    prob_update                    shift and go to state 78
    updates                        shift and go to state 79
    factor                         shift and go to state 41

state 51

    (39) boolean_expression -> boolean_expression OR . boolean_expression_unit
    (41) boolean_expression_unit -> . NAME GT NUM
    (42) boolean_expression_unit -> . NAME LT NUM
    (43) boolean_expression_unit -> . NAME GE NUM
    (44) boolean_expression_unit -> . NAME LE NUM
    (45) boolean_expression_unit -> . NAME EQ NUM
    (46) boolean_expression_unit -> . NAME NEQ NUM
    (47) boolean_expression_unit -> . NAME GT expr
    (48) boolean_expression_unit -> . NAME LT expr
    (49) boolean_expression_unit -> . NAME GE expr
    (50) boolean_expression_unit -> . NAME LE expr
    (51) boolean_expression_unit -> . NAME EQ expr
    (52) boolean_expression_unit -> . NAME NEQ expr

    NAME            shift and go to state 28

    boolean_expression_unit        shift and go to state 80

state 52

    (21) module_var_def_statement -> NAME COLON LB expr . COMMA expr RB INIT NUM SEMICOLON
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    COMMA           shift and go to state 81
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 53

    (18) const_value_statement -> CONST INT NAME ASSIGN expr . SEMICOLON
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 82
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 54

    (12) const_value_statement -> CONST INT NAME ASSIGN NUM . SEMICOLON
    (36) factor -> NUM .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 83
    MUL             reduce using rule 36 (factor -> NUM .)
    DIV             reduce using rule 36 (factor -> NUM .)
    ADD             reduce using rule 36 (factor -> NUM .)
    MINUS           reduce using rule 36 (factor -> NUM .)

  ! SEMICOLON       [ reduce using rule 36 (factor -> NUM .) ]


state 55

    (13) const_value_statement -> CONST DOUBLE NAME ASSIGN NUM . SEMICOLON
    (36) factor -> NUM .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 84
    MUL             reduce using rule 36 (factor -> NUM .)
    DIV             reduce using rule 36 (factor -> NUM .)
    ADD             reduce using rule 36 (factor -> NUM .)
    MINUS           reduce using rule 36 (factor -> NUM .)

  ! SEMICOLON       [ reduce using rule 36 (factor -> NUM .) ]


state 56

    (19) const_value_statement -> CONST DOUBLE NAME ASSIGN expr . SEMICOLON
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 85
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 57

    (20) const_value_statement -> CONST BOOL NAME ASSIGN expr . SEMICOLON
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 86
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 58

    (14) const_value_statement -> CONST BOOL NAME ASSIGN NUM . SEMICOLON
    (36) factor -> NUM .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 87
    MUL             reduce using rule 36 (factor -> NUM .)
    DIV             reduce using rule 36 (factor -> NUM .)
    ADD             reduce using rule 36 (factor -> NUM .)
    MINUS           reduce using rule 36 (factor -> NUM .)

  ! SEMICOLON       [ reduce using rule 36 (factor -> NUM .) ]


state 59

    (33) term -> term MUL . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 42
    NAME            shift and go to state 39

    factor                         shift and go to state 88

state 60

    (34) term -> term DIV . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 42
    NAME            shift and go to state 39

    factor                         shift and go to state 89

state 61

    (53) formula_statement -> FORMULA NAME ASSIGN expr SEMICOLON .

    $end            reduce using rule 53 (formula_statement -> FORMULA NAME ASSIGN expr SEMICOLON .)


state 62

    (31) expr -> expr MINUS . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 42
    NAME            shift and go to state 39

    term                           shift and go to state 90
    factor                         shift and go to state 41

state 63

    (30) expr -> expr ADD . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 42
    NAME            shift and go to state 39

    term                           shift and go to state 91
    factor                         shift and go to state 41

state 64

    (50) boolean_expression_unit -> NAME LE expr .
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    THEN            reduce using rule 50 (boolean_expression_unit -> NAME LE expr .)
    AND             reduce using rule 50 (boolean_expression_unit -> NAME LE expr .)
    OR              reduce using rule 50 (boolean_expression_unit -> NAME LE expr .)
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 65

    (44) boolean_expression_unit -> NAME LE NUM .
    (36) factor -> NUM .

  ! reduce/reduce conflict for THEN resolved using rule 36 (factor -> NUM .)
  ! reduce/reduce conflict for AND resolved using rule 36 (factor -> NUM .)
  ! reduce/reduce conflict for OR resolved using rule 36 (factor -> NUM .)
    MUL             reduce using rule 36 (factor -> NUM .)
    DIV             reduce using rule 36 (factor -> NUM .)
    ADD             reduce using rule 36 (factor -> NUM .)
    MINUS           reduce using rule 36 (factor -> NUM .)
    THEN            reduce using rule 36 (factor -> NUM .)
    AND             reduce using rule 36 (factor -> NUM .)
    OR              reduce using rule 36 (factor -> NUM .)

  ! THEN            [ reduce using rule 44 (boolean_expression_unit -> NAME LE NUM .) ]
  ! AND             [ reduce using rule 44 (boolean_expression_unit -> NAME LE NUM .) ]
  ! OR              [ reduce using rule 44 (boolean_expression_unit -> NAME LE NUM .) ]


state 66

    (47) boolean_expression_unit -> NAME GT expr .
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    THEN            reduce using rule 47 (boolean_expression_unit -> NAME GT expr .)
    AND             reduce using rule 47 (boolean_expression_unit -> NAME GT expr .)
    OR              reduce using rule 47 (boolean_expression_unit -> NAME GT expr .)
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 67

    (41) boolean_expression_unit -> NAME GT NUM .
    (36) factor -> NUM .

  ! reduce/reduce conflict for THEN resolved using rule 36 (factor -> NUM .)
  ! reduce/reduce conflict for AND resolved using rule 36 (factor -> NUM .)
  ! reduce/reduce conflict for OR resolved using rule 36 (factor -> NUM .)
    MUL             reduce using rule 36 (factor -> NUM .)
    DIV             reduce using rule 36 (factor -> NUM .)
    ADD             reduce using rule 36 (factor -> NUM .)
    MINUS           reduce using rule 36 (factor -> NUM .)
    THEN            reduce using rule 36 (factor -> NUM .)
    AND             reduce using rule 36 (factor -> NUM .)
    OR              reduce using rule 36 (factor -> NUM .)

  ! THEN            [ reduce using rule 41 (boolean_expression_unit -> NAME GT NUM .) ]
  ! AND             [ reduce using rule 41 (boolean_expression_unit -> NAME GT NUM .) ]
  ! OR              [ reduce using rule 41 (boolean_expression_unit -> NAME GT NUM .) ]


state 68

    (49) boolean_expression_unit -> NAME GE expr .
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    THEN            reduce using rule 49 (boolean_expression_unit -> NAME GE expr .)
    AND             reduce using rule 49 (boolean_expression_unit -> NAME GE expr .)
    OR              reduce using rule 49 (boolean_expression_unit -> NAME GE expr .)
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 69

    (43) boolean_expression_unit -> NAME GE NUM .
    (36) factor -> NUM .

  ! reduce/reduce conflict for THEN resolved using rule 36 (factor -> NUM .)
  ! reduce/reduce conflict for AND resolved using rule 36 (factor -> NUM .)
  ! reduce/reduce conflict for OR resolved using rule 36 (factor -> NUM .)
    MUL             reduce using rule 36 (factor -> NUM .)
    DIV             reduce using rule 36 (factor -> NUM .)
    ADD             reduce using rule 36 (factor -> NUM .)
    MINUS           reduce using rule 36 (factor -> NUM .)
    THEN            reduce using rule 36 (factor -> NUM .)
    AND             reduce using rule 36 (factor -> NUM .)
    OR              reduce using rule 36 (factor -> NUM .)

  ! THEN            [ reduce using rule 43 (boolean_expression_unit -> NAME GE NUM .) ]
  ! AND             [ reduce using rule 43 (boolean_expression_unit -> NAME GE NUM .) ]
  ! OR              [ reduce using rule 43 (boolean_expression_unit -> NAME GE NUM .) ]


state 70

    (48) boolean_expression_unit -> NAME LT expr .
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    THEN            reduce using rule 48 (boolean_expression_unit -> NAME LT expr .)
    AND             reduce using rule 48 (boolean_expression_unit -> NAME LT expr .)
    OR              reduce using rule 48 (boolean_expression_unit -> NAME LT expr .)
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 71

    (42) boolean_expression_unit -> NAME LT NUM .
    (36) factor -> NUM .

  ! reduce/reduce conflict for THEN resolved using rule 36 (factor -> NUM .)
  ! reduce/reduce conflict for AND resolved using rule 36 (factor -> NUM .)
  ! reduce/reduce conflict for OR resolved using rule 36 (factor -> NUM .)
    MUL             reduce using rule 36 (factor -> NUM .)
    DIV             reduce using rule 36 (factor -> NUM .)
    ADD             reduce using rule 36 (factor -> NUM .)
    MINUS           reduce using rule 36 (factor -> NUM .)
    THEN            reduce using rule 36 (factor -> NUM .)
    AND             reduce using rule 36 (factor -> NUM .)
    OR              reduce using rule 36 (factor -> NUM .)

  ! THEN            [ reduce using rule 42 (boolean_expression_unit -> NAME LT NUM .) ]
  ! AND             [ reduce using rule 42 (boolean_expression_unit -> NAME LT NUM .) ]
  ! OR              [ reduce using rule 42 (boolean_expression_unit -> NAME LT NUM .) ]


state 72

    (51) boolean_expression_unit -> NAME EQ expr .
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    THEN            reduce using rule 51 (boolean_expression_unit -> NAME EQ expr .)
    AND             reduce using rule 51 (boolean_expression_unit -> NAME EQ expr .)
    OR              reduce using rule 51 (boolean_expression_unit -> NAME EQ expr .)
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 73

    (45) boolean_expression_unit -> NAME EQ NUM .
    (36) factor -> NUM .

  ! reduce/reduce conflict for THEN resolved using rule 36 (factor -> NUM .)
  ! reduce/reduce conflict for AND resolved using rule 36 (factor -> NUM .)
  ! reduce/reduce conflict for OR resolved using rule 36 (factor -> NUM .)
    MUL             reduce using rule 36 (factor -> NUM .)
    DIV             reduce using rule 36 (factor -> NUM .)
    ADD             reduce using rule 36 (factor -> NUM .)
    MINUS           reduce using rule 36 (factor -> NUM .)
    THEN            reduce using rule 36 (factor -> NUM .)
    AND             reduce using rule 36 (factor -> NUM .)
    OR              reduce using rule 36 (factor -> NUM .)

  ! THEN            [ reduce using rule 45 (boolean_expression_unit -> NAME EQ NUM .) ]
  ! AND             [ reduce using rule 45 (boolean_expression_unit -> NAME EQ NUM .) ]
  ! OR              [ reduce using rule 45 (boolean_expression_unit -> NAME EQ NUM .) ]


state 74

    (52) boolean_expression_unit -> NAME NEQ expr .
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    THEN            reduce using rule 52 (boolean_expression_unit -> NAME NEQ expr .)
    AND             reduce using rule 52 (boolean_expression_unit -> NAME NEQ expr .)
    OR              reduce using rule 52 (boolean_expression_unit -> NAME NEQ expr .)
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 75

    (46) boolean_expression_unit -> NAME NEQ NUM .
    (36) factor -> NUM .

  ! reduce/reduce conflict for THEN resolved using rule 36 (factor -> NUM .)
  ! reduce/reduce conflict for AND resolved using rule 36 (factor -> NUM .)
  ! reduce/reduce conflict for OR resolved using rule 36 (factor -> NUM .)
    MUL             reduce using rule 36 (factor -> NUM .)
    DIV             reduce using rule 36 (factor -> NUM .)
    ADD             reduce using rule 36 (factor -> NUM .)
    MINUS           reduce using rule 36 (factor -> NUM .)
    THEN            reduce using rule 36 (factor -> NUM .)
    AND             reduce using rule 36 (factor -> NUM .)
    OR              reduce using rule 36 (factor -> NUM .)

  ! THEN            [ reduce using rule 46 (boolean_expression_unit -> NAME NEQ NUM .) ]
  ! AND             [ reduce using rule 46 (boolean_expression_unit -> NAME NEQ NUM .) ]
  ! OR              [ reduce using rule 46 (boolean_expression_unit -> NAME NEQ NUM .) ]


state 76

    (38) boolean_expression -> boolean_expression AND boolean_expression_unit .

    THEN            reduce using rule 38 (boolean_expression -> boolean_expression AND boolean_expression_unit .)
    AND             reduce using rule 38 (boolean_expression -> boolean_expression AND boolean_expression_unit .)
    OR              reduce using rule 38 (boolean_expression -> boolean_expression AND boolean_expression_unit .)


state 77

    (25) prob_update -> expr . COLON actions
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    COLON           shift and go to state 92
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 78

    (24) updates -> prob_update .

    SEMICOLON       reduce using rule 24 (updates -> prob_update .)
    ADD             reduce using rule 24 (updates -> prob_update .)


state 79

    (22) module_command_statement -> LB RB boolean_expression THEN updates . SEMICOLON
    (23) updates -> updates . ADD prob_update

    SEMICOLON       shift and go to state 93
    ADD             shift and go to state 94


state 80

    (39) boolean_expression -> boolean_expression OR boolean_expression_unit .

    THEN            reduce using rule 39 (boolean_expression -> boolean_expression OR boolean_expression_unit .)
    AND             reduce using rule 39 (boolean_expression -> boolean_expression OR boolean_expression_unit .)
    OR              reduce using rule 39 (boolean_expression -> boolean_expression OR boolean_expression_unit .)


state 81

    (21) module_var_def_statement -> NAME COLON LB expr COMMA . expr RB INIT NUM SEMICOLON
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 42
    NAME            shift and go to state 39

    expr                           shift and go to state 95
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 82

    (18) const_value_statement -> CONST INT NAME ASSIGN expr SEMICOLON .

    $end            reduce using rule 18 (const_value_statement -> CONST INT NAME ASSIGN expr SEMICOLON .)


state 83

    (12) const_value_statement -> CONST INT NAME ASSIGN NUM SEMICOLON .

    $end            reduce using rule 12 (const_value_statement -> CONST INT NAME ASSIGN NUM SEMICOLON .)


state 84

    (13) const_value_statement -> CONST DOUBLE NAME ASSIGN NUM SEMICOLON .

    $end            reduce using rule 13 (const_value_statement -> CONST DOUBLE NAME ASSIGN NUM SEMICOLON .)


state 85

    (19) const_value_statement -> CONST DOUBLE NAME ASSIGN expr SEMICOLON .

    $end            reduce using rule 19 (const_value_statement -> CONST DOUBLE NAME ASSIGN expr SEMICOLON .)


state 86

    (20) const_value_statement -> CONST BOOL NAME ASSIGN expr SEMICOLON .

    $end            reduce using rule 20 (const_value_statement -> CONST BOOL NAME ASSIGN expr SEMICOLON .)


state 87

    (14) const_value_statement -> CONST BOOL NAME ASSIGN NUM SEMICOLON .

    $end            reduce using rule 14 (const_value_statement -> CONST BOOL NAME ASSIGN NUM SEMICOLON .)


state 88

    (33) term -> term MUL factor .

    MUL             reduce using rule 33 (term -> term MUL factor .)
    DIV             reduce using rule 33 (term -> term MUL factor .)
    ADD             reduce using rule 33 (term -> term MUL factor .)
    MINUS           reduce using rule 33 (term -> term MUL factor .)
    THEN            reduce using rule 33 (term -> term MUL factor .)
    AND             reduce using rule 33 (term -> term MUL factor .)
    OR              reduce using rule 33 (term -> term MUL factor .)
    RB              reduce using rule 33 (term -> term MUL factor .)
    COMMA           reduce using rule 33 (term -> term MUL factor .)
    SEMICOLON       reduce using rule 33 (term -> term MUL factor .)
    RP              reduce using rule 33 (term -> term MUL factor .)
    COLON           reduce using rule 33 (term -> term MUL factor .)


state 89

    (34) term -> term DIV factor .

    MUL             reduce using rule 34 (term -> term DIV factor .)
    DIV             reduce using rule 34 (term -> term DIV factor .)
    ADD             reduce using rule 34 (term -> term DIV factor .)
    MINUS           reduce using rule 34 (term -> term DIV factor .)
    THEN            reduce using rule 34 (term -> term DIV factor .)
    AND             reduce using rule 34 (term -> term DIV factor .)
    OR              reduce using rule 34 (term -> term DIV factor .)
    RB              reduce using rule 34 (term -> term DIV factor .)
    COMMA           reduce using rule 34 (term -> term DIV factor .)
    SEMICOLON       reduce using rule 34 (term -> term DIV factor .)
    RP              reduce using rule 34 (term -> term DIV factor .)
    COLON           reduce using rule 34 (term -> term DIV factor .)


state 90

    (31) expr -> expr MINUS term .
    (33) term -> term . MUL factor
    (34) term -> term . DIV factor

    SEMICOLON       reduce using rule 31 (expr -> expr MINUS term .)
    ADD             reduce using rule 31 (expr -> expr MINUS term .)
    MINUS           reduce using rule 31 (expr -> expr MINUS term .)
    THEN            reduce using rule 31 (expr -> expr MINUS term .)
    AND             reduce using rule 31 (expr -> expr MINUS term .)
    OR              reduce using rule 31 (expr -> expr MINUS term .)
    COLON           reduce using rule 31 (expr -> expr MINUS term .)
    COMMA           reduce using rule 31 (expr -> expr MINUS term .)
    RP              reduce using rule 31 (expr -> expr MINUS term .)
    RB              reduce using rule 31 (expr -> expr MINUS term .)
    MUL             shift and go to state 59
    DIV             shift and go to state 60


state 91

    (30) expr -> expr ADD term .
    (33) term -> term . MUL factor
    (34) term -> term . DIV factor

    SEMICOLON       reduce using rule 30 (expr -> expr ADD term .)
    ADD             reduce using rule 30 (expr -> expr ADD term .)
    MINUS           reduce using rule 30 (expr -> expr ADD term .)
    THEN            reduce using rule 30 (expr -> expr ADD term .)
    AND             reduce using rule 30 (expr -> expr ADD term .)
    OR              reduce using rule 30 (expr -> expr ADD term .)
    COLON           reduce using rule 30 (expr -> expr ADD term .)
    COMMA           reduce using rule 30 (expr -> expr ADD term .)
    RP              reduce using rule 30 (expr -> expr ADD term .)
    RB              reduce using rule 30 (expr -> expr ADD term .)
    MUL             shift and go to state 59
    DIV             shift and go to state 60


state 92

    (25) prob_update -> expr COLON . actions
    (26) actions -> . actions AND assignment
    (27) actions -> . assignment
    (28) assignment -> . NAME ASSIGN expr
    (29) assignment -> . LP NAME ASSIGN expr RP

    NAME            shift and go to state 96
    LP              shift and go to state 98

    actions                        shift and go to state 97
    assignment                     shift and go to state 99

state 93

    (22) module_command_statement -> LB RB boolean_expression THEN updates SEMICOLON .

    $end            reduce using rule 22 (module_command_statement -> LB RB boolean_expression THEN updates SEMICOLON .)


state 94

    (23) updates -> updates ADD . prob_update
    (25) prob_update -> . expr COLON actions
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 42
    NAME            shift and go to state 39

    term                           shift and go to state 38
    expr                           shift and go to state 77
    prob_update                    shift and go to state 100
    factor                         shift and go to state 41

state 95

    (21) module_var_def_statement -> NAME COLON LB expr COMMA expr . RB INIT NUM SEMICOLON
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    RB              shift and go to state 101
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 96

    (28) assignment -> NAME . ASSIGN expr

    ASSIGN          shift and go to state 102


state 97

    (25) prob_update -> expr COLON actions .
    (26) actions -> actions . AND assignment

    SEMICOLON       reduce using rule 25 (prob_update -> expr COLON actions .)
    ADD             reduce using rule 25 (prob_update -> expr COLON actions .)
    AND             shift and go to state 103


state 98

    (29) assignment -> LP . NAME ASSIGN expr RP

    NAME            shift and go to state 104


state 99

    (27) actions -> assignment .

    AND             reduce using rule 27 (actions -> assignment .)
    SEMICOLON       reduce using rule 27 (actions -> assignment .)
    ADD             reduce using rule 27 (actions -> assignment .)


state 100

    (23) updates -> updates ADD prob_update .

    SEMICOLON       reduce using rule 23 (updates -> updates ADD prob_update .)
    ADD             reduce using rule 23 (updates -> updates ADD prob_update .)


state 101

    (21) module_var_def_statement -> NAME COLON LB expr COMMA expr RB . INIT NUM SEMICOLON

    INIT            shift and go to state 105


state 102

    (28) assignment -> NAME ASSIGN . expr
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 42
    NAME            shift and go to state 39

    expr                           shift and go to state 106
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 103

    (26) actions -> actions AND . assignment
    (28) assignment -> . NAME ASSIGN expr
    (29) assignment -> . LP NAME ASSIGN expr RP

    NAME            shift and go to state 96
    LP              shift and go to state 98

    assignment                     shift and go to state 107

state 104

    (29) assignment -> LP NAME . ASSIGN expr RP

    ASSIGN          shift and go to state 108


state 105

    (21) module_var_def_statement -> NAME COLON LB expr COMMA expr RB INIT . NUM SEMICOLON

    NUM             shift and go to state 109


state 106

    (28) assignment -> NAME ASSIGN expr .
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

  ! shift/reduce conflict for ADD resolved as shift
    AND             reduce using rule 28 (assignment -> NAME ASSIGN expr .)
    SEMICOLON       reduce using rule 28 (assignment -> NAME ASSIGN expr .)
    ADD             shift and go to state 63
    MINUS           shift and go to state 62

  ! ADD             [ reduce using rule 28 (assignment -> NAME ASSIGN expr .) ]


state 107

    (26) actions -> actions AND assignment .

    AND             reduce using rule 26 (actions -> actions AND assignment .)
    SEMICOLON       reduce using rule 26 (actions -> actions AND assignment .)
    ADD             reduce using rule 26 (actions -> actions AND assignment .)


state 108

    (29) assignment -> LP NAME ASSIGN . expr RP
    (30) expr -> . expr ADD term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . NUM
    (37) factor -> . NAME

    NUM             shift and go to state 42
    NAME            shift and go to state 39

    expr                           shift and go to state 110
    term                           shift and go to state 38
    factor                         shift and go to state 41

state 109

    (21) module_var_def_statement -> NAME COLON LB expr COMMA expr RB INIT NUM . SEMICOLON

    SEMICOLON       shift and go to state 111


state 110

    (29) assignment -> LP NAME ASSIGN expr . RP
    (30) expr -> expr . ADD term
    (31) expr -> expr . MINUS term

    RP              shift and go to state 112
    ADD             shift and go to state 63
    MINUS           shift and go to state 62


state 111

    (21) module_var_def_statement -> NAME COLON LB expr COMMA expr RB INIT NUM SEMICOLON .

    $end            reduce using rule 21 (module_var_def_statement -> NAME COLON LB expr COMMA expr RB INIT NUM SEMICOLON .)


state 112

    (29) assignment -> LP NAME ASSIGN expr RP .

    AND             reduce using rule 29 (assignment -> LP NAME ASSIGN expr RP .)
    SEMICOLON       reduce using rule 29 (assignment -> LP NAME ASSIGN expr RP .)
    ADD             reduce using rule 29 (assignment -> LP NAME ASSIGN expr RP .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 54 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 55 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 58 resolved as shift
WARNING: shift/reduce conflict for ADD in state 106 resolved as shift
WARNING: reduce/reduce conflict in state 65 resolved using rule (factor -> NUM)
WARNING: rejected rule (boolean_expression_unit -> NAME LE NUM) in state 65
WARNING: reduce/reduce conflict in state 67 resolved using rule (factor -> NUM)
WARNING: rejected rule (boolean_expression_unit -> NAME GT NUM) in state 67
WARNING: reduce/reduce conflict in state 69 resolved using rule (factor -> NUM)
WARNING: rejected rule (boolean_expression_unit -> NAME GE NUM) in state 69
WARNING: reduce/reduce conflict in state 71 resolved using rule (factor -> NUM)
WARNING: rejected rule (boolean_expression_unit -> NAME LT NUM) in state 71
WARNING: reduce/reduce conflict in state 73 resolved using rule (factor -> NUM)
WARNING: rejected rule (boolean_expression_unit -> NAME EQ NUM) in state 73
WARNING: reduce/reduce conflict in state 75 resolved using rule (factor -> NUM)
WARNING: rejected rule (boolean_expression_unit -> NAME NEQ NUM) in state 75
WARNING: Rule (boolean_expression_unit -> NAME LE NUM) is never reduced
WARNING: Rule (boolean_expression_unit -> NAME GT NUM) is never reduced
WARNING: Rule (boolean_expression_unit -> NAME GE NUM) is never reduced
WARNING: Rule (boolean_expression_unit -> NAME LT NUM) is never reduced
WARNING: Rule (boolean_expression_unit -> NAME EQ NUM) is never reduced
WARNING: Rule (boolean_expression_unit -> NAME NEQ NUM) is never reduced
